import{S as ut,T as Bt,U as qt,V as Ot,W as j,X as Ve,Y as Te,Z as At,$ as Ke,a0 as gt,a1 as xt}from"./index-f732781d.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xt=BigInt(0),Mt=BigInt(1);function St(t,n=""){if(typeof t!="boolean"){const r=n&&`"${n}"`;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function ot(t,n,r=""){const e=Ot(t),o=t==null?void 0:t.length,s=n!==void 0;if(!e||s&&o!==n){const i=r&&`"${r}" `,f=s?` of length ${n}`:"",c=e?`length=${o}`:`type=${typeof t}`;throw new Error(i+"expected Uint8Array"+f+", got "+c)}return t}function vt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function ae(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Xt:BigInt("0x"+t)}function ft(t){return ae(ut(t))}function ue(t){return qt(t),ae(ut(Uint8Array.from(t).reverse()))}function It(t,n){return Bt(t.toString(16).padStart(n*2,"0"))}function le(t,n){return It(t,n).reverse()}function L(t,n,r){let e;if(typeof n=="string")try{e=Bt(n)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(Ot(n))e=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const o=e.length;if(typeof r=="number"&&o!==r)throw new Error(t+" of length "+r+" expected, got "+o);return e}const Ut=t=>typeof t=="bigint"&&Xt<=t;function $t(t,n,r){return Ut(t)&&Ut(n)&&Ut(r)&&n<=t&&t<r}function Ce(t,n,r,e){if(!$t(n,r,e))throw new Error("expected valid "+t+": "+r+" <= n < "+e+", got "+n)}function de(t){let n;for(n=0;t>Xt;t>>=Mt,n+=1);return n}const bt=t=>(Mt<<BigInt(t))-Mt;function ke(t,n,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const e=u=>new Uint8Array(u),o=u=>Uint8Array.of(u);let s=e(t),i=e(t),f=0;const c=()=>{s.fill(1),i.fill(0),f=0},d=(...u)=>r(i,s,...u),m=(u=e(0))=>{i=d(o(0),u),s=d(),u.length!==0&&(i=d(o(1),u),s=d())},y=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const g=[];for(;u<n;){s=d();const E=s.slice();g.push(E),u+=s.length}return j(...g)};return(u,g)=>{c(),m(u);let E;for(;!(E=g(y()));)m();return c(),E}}function Le(t){return typeof t=="function"&&Number.isSafeInteger(t.outputLen)}function Nt(t,n,r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function e(o,s,i){const f=t[o];if(i&&f===void 0)return;const c=typeof f;if(c!==s||f===null)throw new Error(`param "${o}" is invalid: expected ${s}, got ${c}`)}Object.entries(n).forEach(([o,s])=>e(o,s,!1)),Object.entries(r).forEach(([o,s])=>e(o,s,!0))}function Ft(t){const n=new WeakMap;return(r,...e)=>{const o=n.get(r);if(o!==void 0)return o;const s=t(r,...e);return n.set(r,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const X=BigInt(0),H=BigInt(1),st=BigInt(2),he=BigInt(3),we=BigInt(4),me=BigInt(5),Me=BigInt(7),ge=BigInt(8),$e=BigInt(9),be=BigInt(16);function D(t,n){const r=t%n;return r>=X?r:n+r}function W(t,n,r){let e=t;for(;n-- >X;)e*=e,e%=r;return e}function te(t,n){if(t===X)throw new Error("invert: expected non-zero number");if(n<=X)throw new Error("invert: expected positive modulus, got "+n);let r=D(t,n),e=n,o=X,s=H;for(;r!==X;){const f=e/r,c=e%r,d=o-s*f;e=r,r=c,o=s,s=d}if(e!==H)throw new Error("invert: does not exist");return D(o,n)}function Dt(t,n,r){if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root")}function ye(t,n){const r=(t.ORDER+H)/we,e=t.pow(n,r);return Dt(t,e,n),e}function je(t,n){const r=(t.ORDER-me)/ge,e=t.mul(n,st),o=t.pow(e,r),s=t.mul(n,o),i=t.mul(t.mul(s,st),o),f=t.mul(s,t.sub(i,t.ONE));return Dt(t,f,n),f}function He(t){const n=yt(t),r=Ee(t),e=r(n,n.neg(n.ONE)),o=r(n,e),s=r(n,n.neg(e)),i=(t+Me)/be;return(f,c)=>{let d=f.pow(c,i),m=f.mul(d,e);const y=f.mul(d,o),a=f.mul(d,s),u=f.eql(f.sqr(m),c),g=f.eql(f.sqr(y),c);d=f.cmov(d,m,u),m=f.cmov(a,y,g);const E=f.eql(f.sqr(m),c),S=f.cmov(d,m,E);return Dt(f,S,c),S}}function Ee(t){if(t<he)throw new Error("sqrt is not defined for small field");let n=t-H,r=0;for(;n%st===X;)n/=st,r++;let e=st;const o=yt(t);for(;ee(o,e)===1;)if(e++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return ye;let s=o.pow(e,n);const i=(n+H)/st;return function(c,d){if(c.is0(d))return d;if(ee(c,d)!==1)throw new Error("Cannot find square root");let m=r,y=c.mul(c.ONE,s),a=c.pow(d,n),u=c.pow(d,i);for(;!c.eql(a,c.ONE);){if(c.is0(a))return c.ZERO;let g=1,E=c.sqr(a);for(;!c.eql(E,c.ONE);)if(g++,E=c.sqr(E),g===m)throw new Error("Cannot find square root");const S=H<<BigInt(m-g-1),R=c.pow(y,S);m=g,y=c.sqr(R),a=c.mul(a,y),u=c.mul(u,R)}return u}}function Ye(t){return t%we===he?ye:t%ge===me?je:t%be===$e?He(t):Ee(t)}const ze=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function pe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=ze.reduce((e,o)=>(e[o]="function",e),n);return Nt(t,r),t}function Xe(t,n,r){if(r<X)throw new Error("invalid exponent, negatives unsupported");if(r===X)return t.ONE;if(r===H)return n;let e=t.ONE,o=n;for(;r>X;)r&H&&(e=t.mul(e,o)),o=t.sqr(o),r>>=H;return e}function Zt(t,n,r=!1){const e=new Array(n.length).fill(r?t.ZERO:void 0),o=n.reduce((i,f,c)=>t.is0(f)?i:(e[c]=i,t.mul(i,f)),t.ONE),s=t.inv(o);return n.reduceRight((i,f,c)=>t.is0(f)?i:(e[c]=t.mul(i,e[c]),t.mul(i,f)),s),e}function ee(t,n){const r=(t.ORDER-H)/st,e=t.pow(n,r),o=t.eql(e,t.ONE),s=t.eql(e,t.ZERO),i=t.eql(e,t.neg(t.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function ve(t,n){n!==void 0&&Ve(n);const r=n!==void 0?n:t.toString(2).length,e=Math.ceil(r/8);return{nBitLength:r,nByteLength:e}}function yt(t,n,r=!1,e={}){if(t<=X)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,s,i=!1,f;if(typeof n=="object"&&n!=null){if(e.sqrt||r)throw new Error("cannot specify opts in two arguments");const a=n;a.BITS&&(o=a.BITS),a.sqrt&&(s=a.sqrt),typeof a.isLE=="boolean"&&(r=a.isLE),typeof a.modFromBytes=="boolean"&&(i=a.modFromBytes),f=a.allowedLengths}else typeof n=="number"&&(o=n),e.sqrt&&(s=e.sqrt);const{nBitLength:c,nByteLength:d}=ve(t,o);if(d>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let m;const y=Object.freeze({ORDER:t,isLE:r,BITS:c,BYTES:d,MASK:bt(c),ZERO:X,ONE:H,allowedLengths:f,create:a=>D(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return X<=a&&a<t},is0:a=>a===X,isValidNot0:a=>!y.is0(a)&&y.isValid(a),isOdd:a=>(a&H)===H,neg:a=>D(-a,t),eql:(a,u)=>a===u,sqr:a=>D(a*a,t),add:(a,u)=>D(a+u,t),sub:(a,u)=>D(a-u,t),mul:(a,u)=>D(a*u,t),pow:(a,u)=>Xe(y,a,u),div:(a,u)=>D(a*te(u,t),t),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>te(a,t),sqrt:s||(a=>(m||(m=Ye(t)),m(y,a))),toBytes:a=>r?le(a,d):It(a,d),fromBytes:(a,u=!0)=>{if(f){if(!f.includes(a.length)||a.length>d)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+a.length);const E=new Uint8Array(d);E.set(a,r?0:E.length-a.length),a=E}if(a.length!==d)throw new Error("Field.fromBytes: expected "+d+" bytes, got "+a.length);let g=r?ue(a):ft(a);if(i&&(g=D(g,t)),!u&&!y.isValid(g))throw new Error("invalid field element: outside of range 0..ORDER");return g},invertBatch:a=>Zt(y,a),cmov:(a,u,g)=>g?u:a});return Object.freeze(y)}function Be(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function xe(t){const n=Be(t);return n+Math.ceil(n/2)}function Se(t,n,r=!1){const e=t.length,o=Be(n),s=xe(n);if(e<16||e<s||e>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+e);const i=r?ue(t):ft(t),f=D(i,n-H)+H;return r?le(f,o):It(f,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const lt=BigInt(0),it=BigInt(1);function _t(t,n){const r=n.negate();return t?r:n}function Vt(t,n){const r=Zt(t.Fp,n.map(e=>e.Z));return n.map((e,o)=>t.fromAffine(e.toAffine(r[o])))}function _e(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Tt(t,n){_e(t,n);const r=Math.ceil(n/t)+1,e=2**(t-1),o=2**t,s=bt(t),i=BigInt(t);return{windows:r,windowSize:e,mask:s,maxNumber:o,shiftBy:i}}function ne(t,n,r){const{windowSize:e,mask:o,maxNumber:s,shiftBy:i}=r;let f=Number(t&o),c=t>>i;f>e&&(f-=s,c+=it);const d=n*e,m=d+Math.abs(f)-1,y=f===0,a=f<0,u=n%2!==0;return{nextN:c,offset:m,isZero:y,isNeg:a,isNegF:u,offsetF:d}}function De(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,e)=>{if(!(r instanceof n))throw new Error("invalid point at index "+e)})}function Ge(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,e)=>{if(!n.isValid(r))throw new Error("invalid scalar at index "+e)})}const Kt=new WeakMap,Re=new WeakMap;function Ct(t){return Re.get(t)||1}function re(t){if(t!==lt)throw new Error("invalid wNAF")}class Pe{constructor(n,r){this.BASE=n.BASE,this.ZERO=n.ZERO,this.Fn=n.Fn,this.bits=r}_unsafeLadder(n,r,e=this.ZERO){let o=n;for(;r>lt;)r&it&&(e=e.add(o)),o=o.double(),r>>=it;return e}precomputeWindow(n,r){const{windows:e,windowSize:o}=Tt(r,this.bits),s=[];let i=n,f=i;for(let c=0;c<e;c++){f=i,s.push(f);for(let d=1;d<o;d++)f=f.add(i),s.push(f);i=f.double()}return s}wNAF(n,r,e){if(!this.Fn.isValid(e))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE;const i=Tt(n,this.bits);for(let f=0;f<i.windows;f++){const{nextN:c,offset:d,isZero:m,isNeg:y,isNegF:a,offsetF:u}=ne(e,f,i);e=c,m?s=s.add(_t(a,r[u])):o=o.add(_t(y,r[d]))}return re(e),{p:o,f:s}}wNAFUnsafe(n,r,e,o=this.ZERO){const s=Tt(n,this.bits);for(let i=0;i<s.windows&&e!==lt;i++){const{nextN:f,offset:c,isZero:d,isNeg:m}=ne(e,i,s);if(e=f,!d){const y=r[c];o=o.add(m?y.negate():y)}}return re(e),o}getPrecomputes(n,r,e){let o=Kt.get(r);return o||(o=this.precomputeWindow(r,n),n!==1&&(typeof e=="function"&&(o=e(o)),Kt.set(r,o))),o}cached(n,r,e){const o=Ct(n);return this.wNAF(o,this.getPrecomputes(o,n,e),r)}unsafe(n,r,e,o){const s=Ct(n);return s===1?this._unsafeLadder(n,r,o):this.wNAFUnsafe(s,this.getPrecomputes(s,n,e),r,o)}createCache(n,r){_e(r,this.bits),Re.set(n,r),Kt.delete(n)}hasCache(n){return Ct(n)!==1}}function We(t,n,r,e){let o=n,s=t.ZERO,i=t.ZERO;for(;r>lt||e>lt;)r&it&&(s=s.add(o)),e&it&&(i=i.add(o)),o=o.double(),r>>=it,e>>=it;return{p1:s,p2:i}}function Qe(t,n,r,e){De(r,t),Ge(e,n);const o=r.length,s=e.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,f=de(BigInt(o));let c=1;f>12?c=f-3:f>4?c=f-2:f>0&&(c=2);const d=bt(c),m=new Array(Number(d)+1).fill(i),y=Math.floor((n.BITS-1)/c)*c;let a=i;for(let u=y;u>=0;u-=c){m.fill(i);for(let E=0;E<s;E++){const S=e[E],R=Number(S>>BigInt(u)&d);m[R]=m[R].add(r[E])}let g=i;for(let E=m.length-1,S=i;E>0;E--)S=S.add(m[E]),g=g.add(S);if(a=a.add(g),u!==0)for(let E=0;E<c;E++)a=a.double()}return a}function oe(t,n,r){if(n){if(n.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return pe(n),n}else return yt(t,{isLE:r})}function Je(t,n,r={},e){if(e===void 0&&(e=t==="edwards"),!n||typeof n!="object")throw new Error(`expected valid ${t} CURVE object`);for(const c of["p","n","h"]){const d=n[c];if(!(typeof d=="bigint"&&d>lt))throw new Error(`CURVE.${c} must be positive bigint`)}const o=oe(n.p,r.Fp,e),s=oe(n.n,r.Fn,e),f=["Gx","Gy","a",t==="weierstrass"?"b":"d"];for(const c of f)if(!o.isValid(n[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return n=Object.freeze(Object.assign({},n)),{CURVE:n,Fp:o,Fn:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const se=(t,n)=>(t+(t>=0?n:-n)/F)/n;function Fe(t,n,r){const[[e,o],[s,i]]=n,f=se(i*t,r),c=se(-o*t,r);let d=t-f*e-c*s,m=-f*o-c*i;const y=d<J,a=m<J;y&&(d=-d),a&&(m=-m);const u=bt(Math.ceil(de(r)/2))+$;if(d<J||d>=u||m<J||m>=u)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:y,k1:d,k2neg:a,k2:m}}function jt(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function kt(t,n){const r={};for(let e of Object.keys(n))r[e]=t[e]===void 0?n[e]:t[e];return St(r.lowS,"lowS"),St(r.prehash,"prehash"),r.format!==void 0&&jt(r.format),r}class tn extends Error{constructor(n=""){super(n)}}const tt={Err:tn,_tlv:{encode:(t,n)=>{const{Err:r}=tt;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length&1)throw new r("tlv.encode: unpadded data");const e=n.length/2,o=vt(e);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const s=e>127?vt(o.length/2|128):"";return vt(t)+s+o+n},decode(t,n){const{Err:r}=tt;let e=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length<2||n[e++]!==t)throw new r("tlv.decode: wrong tlv");const o=n[e++],s=!!(o&128);let i=0;if(!s)i=o;else{const c=o&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");const d=n.subarray(e,e+c);if(d.length!==c)throw new r("tlv.decode: length bytes not complete");if(d[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const m of d)i=i<<8|m;if(e+=c,i<128)throw new r("tlv.decode(long): not minimal encoding")}const f=n.subarray(e,e+i);if(f.length!==i)throw new r("tlv.decode: wrong value length");return{v:f,l:n.subarray(e+i)}}},_int:{encode(t){const{Err:n}=tt;if(t<J)throw new n("integer: negative integers are not allowed");let r=vt(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:n}=tt;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ft(t)}},toSig(t){const{Err:n,_int:r,_tlv:e}=tt,o=L("signature",t),{v:s,l:i}=e.decode(48,o);if(i.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:c}=e.decode(2,s),{v:d,l:m}=e.decode(2,c);if(m.length)throw new n("invalid signature: left bytes after parsing");return{r:r.decode(f),s:r.decode(d)}},hexFromSig(t){const{_tlv:n,_int:r}=tt,e=n.encode(2,r.encode(t.r)),o=n.encode(2,r.encode(t.s)),s=e+o;return n.encode(48,s)}},J=BigInt(0),$=BigInt(1),F=BigInt(2),at=BigInt(3),Ht=BigInt(4);function ct(t,n){const{BYTES:r}=t;let e;if(typeof n=="bigint")e=n;else{let o=L("private key",n);try{e=t.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof n}`)}}if(!t.isValidNot0(e))throw new Error("invalid private key: out of range [1..N-1]");return e}function en(t,n={}){const r=Je("weierstrass",t,n),{Fp:e,Fn:o}=r;let s=r.CURVE;const{h:i,n:f}=s;Nt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=n;if(c&&(!e.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const d=Oe(e,o);function m(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function y(N,w,h){const{x:l,y:b}=w.toAffine(),p=e.toBytes(l);if(St(h,"isCompressed"),h){m();const x=!e.isOdd(b);return j(qe(x),p)}else return j(Uint8Array.of(4),p,e.toBytes(b))}function a(N){ot(N,void 0,"Point");const{publicKey:w,publicKeyUncompressed:h}=d,l=N.length,b=N[0],p=N.subarray(1);if(l===w&&(b===2||b===3)){const x=e.fromBytes(p);if(!e.isValid(x))throw new Error("bad point: is not on curve, wrong x");const B=E(x);let v;try{v=e.sqrt(B)}catch(C){const U=C instanceof Error?": "+C.message:"";throw new Error("bad point: is not on curve, sqrt error"+U)}m();const _=e.isOdd(v);return(b&1)===1!==_&&(v=e.neg(v)),{x,y:v}}else if(l===h&&b===4){const x=e.BYTES,B=e.fromBytes(p.subarray(0,x)),v=e.fromBytes(p.subarray(x,x*2));if(!S(B,v))throw new Error("bad point: is not on curve");return{x:B,y:v}}else throw new Error(`bad point: got length ${l}, expected compressed=${w} or uncompressed=${h}`)}const u=n.toBytes||y,g=n.fromBytes||a;function E(N){const w=e.sqr(N),h=e.mul(w,N);return e.add(e.add(h,e.mul(N,s.a)),s.b)}function S(N,w){const h=e.sqr(w),l=E(N);return e.eql(h,l)}if(!S(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const R=e.mul(e.pow(s.a,at),Ht),Z=e.mul(e.sqr(s.b),BigInt(27));if(e.is0(e.add(R,Z)))throw new Error("bad curve params: a or b");function A(N,w,h=!1){if(!e.isValid(w)||h&&e.is0(w))throw new Error(`bad point coordinate ${N}`);return w}function V(N){if(!(N instanceof O))throw new Error("ProjectivePoint expected")}function Y(N){if(!c||!c.basises)throw new Error("no endo");return Fe(N,c.basises,o.ORDER)}const G=Ft((N,w)=>{const{X:h,Y:l,Z:b}=N;if(e.eql(b,e.ONE))return{x:h,y:l};const p=N.is0();w==null&&(w=p?e.ONE:e.inv(b));const x=e.mul(h,w),B=e.mul(l,w),v=e.mul(b,w);if(p)return{x:e.ZERO,y:e.ZERO};if(!e.eql(v,e.ONE))throw new Error("invZ was invalid");return{x,y:B}}),Q=Ft(N=>{if(N.is0()){if(n.allowInfinityPoint&&!e.is0(N.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:h}=N.toAffine();if(!e.isValid(w)||!e.isValid(h))throw new Error("bad point: x or y not field elements");if(!S(w,h))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function P(N,w,h,l,b){return h=new O(e.mul(h.X,N),h.Y,h.Z),w=_t(l,w),h=_t(b,h),w.add(h)}class O{constructor(w,h,l){this.X=A("x",w),this.Y=A("y",h,!0),this.Z=A("z",l),Object.freeze(this)}static CURVE(){return s}static fromAffine(w){const{x:h,y:l}=w||{};if(!w||!e.isValid(h)||!e.isValid(l))throw new Error("invalid affine point");if(w instanceof O)throw new Error("projective point not allowed");return e.is0(h)&&e.is0(l)?O.ZERO:new O(h,l,e.ONE)}static fromBytes(w){const h=O.fromAffine(g(ot(w,void 0,"point")));return h.assertValidity(),h}static fromHex(w){return O.fromBytes(L("pointHex",w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,h=!0){return rt.createCache(this,w),h||this.multiply(at),this}assertValidity(){Q(this)}hasEvenY(){const{y:w}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(w)}equals(w){V(w);const{X:h,Y:l,Z:b}=this,{X:p,Y:x,Z:B}=w,v=e.eql(e.mul(h,B),e.mul(p,b)),_=e.eql(e.mul(l,B),e.mul(x,b));return v&&_}negate(){return new O(this.X,e.neg(this.Y),this.Z)}double(){const{a:w,b:h}=s,l=e.mul(h,at),{X:b,Y:p,Z:x}=this;let B=e.ZERO,v=e.ZERO,_=e.ZERO,q=e.mul(b,b),C=e.mul(p,p),U=e.mul(x,x),I=e.mul(b,p);return I=e.add(I,I),_=e.mul(b,x),_=e.add(_,_),B=e.mul(w,_),v=e.mul(l,U),v=e.add(B,v),B=e.sub(C,v),v=e.add(C,v),v=e.mul(B,v),B=e.mul(I,B),_=e.mul(l,_),U=e.mul(w,U),I=e.sub(q,U),I=e.mul(w,I),I=e.add(I,_),_=e.add(q,q),q=e.add(_,q),q=e.add(q,U),q=e.mul(q,I),v=e.add(v,q),U=e.mul(p,x),U=e.add(U,U),q=e.mul(U,I),B=e.sub(B,q),_=e.mul(U,C),_=e.add(_,_),_=e.add(_,_),new O(B,v,_)}add(w){V(w);const{X:h,Y:l,Z:b}=this,{X:p,Y:x,Z:B}=w;let v=e.ZERO,_=e.ZERO,q=e.ZERO;const C=s.a,U=e.mul(s.b,at);let I=e.mul(h,p),T=e.mul(l,x),k=e.mul(b,B),z=e.add(h,l),K=e.add(p,x);z=e.mul(z,K),K=e.add(I,T),z=e.sub(z,K),K=e.add(h,b);let M=e.add(p,B);return K=e.mul(K,M),M=e.add(I,k),K=e.sub(K,M),M=e.add(l,b),v=e.add(x,B),M=e.mul(M,v),v=e.add(T,k),M=e.sub(M,v),q=e.mul(C,K),v=e.mul(U,k),q=e.add(v,q),v=e.sub(T,q),q=e.add(T,q),_=e.mul(v,q),T=e.add(I,I),T=e.add(T,I),k=e.mul(C,k),K=e.mul(U,K),T=e.add(T,k),k=e.sub(I,k),k=e.mul(C,k),K=e.add(K,k),I=e.mul(T,K),_=e.add(_,I),I=e.mul(M,K),v=e.mul(z,v),v=e.sub(v,I),I=e.mul(z,T),q=e.mul(M,q),q=e.add(q,I),new O(v,_,q)}subtract(w){return this.add(w.negate())}is0(){return this.equals(O.ZERO)}multiply(w){const{endo:h}=n;if(!o.isValidNot0(w))throw new Error("invalid scalar: out of range");let l,b;const p=x=>rt.cached(this,x,B=>Vt(O,B));if(h){const{k1neg:x,k1:B,k2neg:v,k2:_}=Y(w),{p:q,f:C}=p(B),{p:U,f:I}=p(_);b=C.add(I),l=P(h.beta,q,U,x,v)}else{const{p:x,f:B}=p(w);l=x,b=B}return Vt(O,[l,b])[0]}multiplyUnsafe(w){const{endo:h}=n,l=this;if(!o.isValid(w))throw new Error("invalid scalar: out of range");if(w===J||l.is0())return O.ZERO;if(w===$)return l;if(rt.hasCache(this))return this.multiply(w);if(h){const{k1neg:b,k1:p,k2neg:x,k2:B}=Y(w),{p1:v,p2:_}=We(O,l,p,B);return P(h.beta,v,_,b,x)}else return rt.unsafe(l,w)}multiplyAndAddUnsafe(w,h,l){const b=this.multiplyUnsafe(h).add(w.multiplyUnsafe(l));return b.is0()?void 0:b}toAffine(w){return G(this,w)}isTorsionFree(){const{isTorsionFree:w}=n;return i===$?!0:w?w(O,this):rt.unsafe(this,f).is0()}clearCofactor(){const{clearCofactor:w}=n;return i===$?this:w?w(O,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(w=!0){return St(w,"isCompressed"),this.assertValidity(),u(O,this,w)}toHex(w=!0){return ut(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(w=!0){return this.toBytes(w)}_setWindowSize(w){this.precompute(w)}static normalizeZ(w){return Vt(O,w)}static msm(w,h){return Qe(O,o,w,h)}static fromPrivateKey(w){return O.BASE.multiply(ct(o,w))}}O.BASE=new O(s.Gx,s.Gy,e.ONE),O.ZERO=new O(e.ZERO,e.ONE,e.ZERO),O.Fp=e,O.Fn=o;const Et=o.BITS,rt=new Pe(O,n.endo?Math.ceil(Et/2):Et);return O.BASE.precompute(8),O}function qe(t){return Uint8Array.of(t?2:3)}function nn(t,n){const r=t.ORDER;let e=J;for(let g=r-$;g%F===J;g/=F)e+=$;const o=e,s=F<<o-$-$,i=s*F,f=(r-$)/i,c=(f-$)/F,d=i-$,m=s,y=t.pow(n,f),a=t.pow(n,(f+$)/F);let u=(g,E)=>{let S=y,R=t.pow(E,d),Z=t.sqr(R);Z=t.mul(Z,E);let A=t.mul(g,Z);A=t.pow(A,c),A=t.mul(A,R),R=t.mul(A,E),Z=t.mul(A,g);let V=t.mul(Z,R);A=t.pow(V,m);let Y=t.eql(A,t.ONE);R=t.mul(Z,a),A=t.mul(V,S),Z=t.cmov(R,Z,Y),V=t.cmov(A,V,Y);for(let G=o;G>$;G--){let Q=G-F;Q=F<<Q-$;let P=t.pow(V,Q);const O=t.eql(P,t.ONE);R=t.mul(Z,S),S=t.mul(S,S),P=t.mul(V,S),Z=t.cmov(R,Z,O),V=t.cmov(P,V,O)}return{isValid:Y,value:Z}};if(t.ORDER%Ht===at){const g=(t.ORDER-at)/Ht,E=t.sqrt(t.neg(n));u=(S,R)=>{let Z=t.sqr(R);const A=t.mul(S,R);Z=t.mul(Z,A);let V=t.pow(Z,g);V=t.mul(V,A);const Y=t.mul(V,E),G=t.mul(t.sqr(V),R),Q=t.eql(G,S);let P=t.cmov(Y,V,Q);return{isValid:Q,value:P}}}return u}function rn(t,n){pe(t);const{A:r,B:e,Z:o}=n;if(!t.isValid(r)||!t.isValid(e)||!t.isValid(o))throw new Error("mapToCurveSimpleSWU: invalid opts");const s=nn(t,o);if(!t.isOdd)throw new Error("Field does not have .isOdd()");return i=>{let f,c,d,m,y,a,u,g;f=t.sqr(i),f=t.mul(f,o),c=t.sqr(f),c=t.add(c,f),d=t.add(c,t.ONE),d=t.mul(d,e),m=t.cmov(o,t.neg(c),!t.eql(c,t.ZERO)),m=t.mul(m,r),c=t.sqr(d),a=t.sqr(m),y=t.mul(a,r),c=t.add(c,y),c=t.mul(c,d),a=t.mul(a,m),y=t.mul(a,e),c=t.add(c,y),u=t.mul(f,d);const{isValid:E,value:S}=s(c,a);g=t.mul(f,i),g=t.mul(g,S),u=t.cmov(u,d,E),g=t.cmov(g,S,E);const R=t.isOdd(i)===t.isOdd(g);g=t.cmov(t.neg(g),g,R);const Z=Zt(t,[m],!0)[0];return u=t.mul(u,Z),{x:u,y:g}}}function Oe(t,n){return{secretKey:n.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*n.BYTES}}function on(t,n={}){const{Fn:r}=t,e=n.randomBytes||At,o=Object.assign(Oe(t.Fp,r),{seed:xe(r.ORDER)});function s(u){try{return!!ct(r,u)}catch{return!1}}function i(u,g){const{publicKey:E,publicKeyUncompressed:S}=o;try{const R=u.length;return g===!0&&R!==E||g===!1&&R!==S?!1:!!t.fromBytes(u)}catch{return!1}}function f(u=e(o.seed)){return Se(ot(u,o.seed,"seed"),r.ORDER)}function c(u,g=!0){return t.BASE.multiply(ct(r,u)).toBytes(g)}function d(u){const g=f(u);return{secretKey:g,publicKey:c(g)}}function m(u){if(typeof u=="bigint")return!1;if(u instanceof t)return!0;const{secretKey:g,publicKey:E,publicKeyUncompressed:S}=o;if(r.allowedLengths||g===E)return;const R=L("key",u).length;return R===E||R===S}function y(u,g,E=!0){if(m(u)===!0)throw new Error("first arg must be private key");if(m(g)===!1)throw new Error("second arg must be public key");const S=ct(r,u);return t.fromHex(g).multiply(S).toBytes(E)}return Object.freeze({getPublicKey:c,getSharedSecret:y,keygen:d,Point:t,utils:{isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:f,isValidPrivateKey:s,randomPrivateKey:f,normPrivateKeyToScalar:u=>ct(r,u),precompute(u=8,g=t.BASE){return g.precompute(u,!1)}},lengths:o})}function sn(t,n,r={}){Te.ahash(n),Nt(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const e=r.randomBytes||At,o=r.hmac||((h,...l)=>Ke(n,h,j(...l))),{Fp:s,Fn:i}=t,{ORDER:f,BITS:c}=i,{keygen:d,getPublicKey:m,getSharedSecret:y,utils:a,lengths:u}=on(t,r),g={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},E="compact";function S(h){const l=f>>$;return h>l}function R(h,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${h}: out of range 1..Point.Fn.ORDER`);return l}function Z(h,l){jt(l);const b=u.signature,p=l==="compact"?b:l==="recovered"?b+1:void 0;return ot(h,p,`${l} signature`)}class A{constructor(l,b,p){this.r=R("r",l),this.s=R("s",b),p!=null&&(this.recovery=p),Object.freeze(this)}static fromBytes(l,b=E){Z(l,b);let p;if(b==="der"){const{r:_,s:q}=tt.toSig(ot(l));return new A(_,q)}b==="recovered"&&(p=l[0],b="compact",l=l.subarray(1));const x=i.BYTES,B=l.subarray(0,x),v=l.subarray(x,x*2);return new A(i.fromBytes(B),i.fromBytes(v),p)}static fromHex(l,b){return this.fromBytes(Bt(l),b)}addRecoveryBit(l){return new A(this.r,this.s,l)}recoverPublicKey(l){const b=s.ORDER,{r:p,s:x,recovery:B}=this;if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");if(f*F<b&&B>1)throw new Error("recovery id is ambiguous for h>1 curve");const _=B===2||B===3?p+f:p;if(!s.isValid(_))throw new Error("recovery id 2 or 3 invalid");const q=s.toBytes(_),C=t.fromBytes(j(qe((B&1)===0),q)),U=i.inv(_),I=Y(L("msgHash",l)),T=i.create(-I*U),k=i.create(x*U),z=t.BASE.multiplyUnsafe(T).add(C.multiplyUnsafe(k));if(z.is0())throw new Error("point at infinify");return z.assertValidity(),z}hasHighS(){return S(this.s)}toBytes(l=E){if(jt(l),l==="der")return Bt(tt.hexFromSig(this));const b=i.toBytes(this.r),p=i.toBytes(this.s);if(l==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return j(Uint8Array.of(this.recovery),b,p)}return j(b,p)}toHex(l){return ut(this.toBytes(l))}assertValidity(){}static fromCompact(l){return A.fromBytes(L("sig",l),"compact")}static fromDER(l){return A.fromBytes(L("sig",l),"der")}normalizeS(){return this.hasHighS()?new A(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return ut(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return ut(this.toBytes("compact"))}}const V=r.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const b=ft(l),p=l.length*8-c;return p>0?b>>BigInt(p):b},Y=r.bits2int_modN||function(l){return i.create(V(l))},G=bt(c);function Q(h){return Ce("num < 2^"+c,h,J,G),i.toBytes(h)}function P(h,l){return ot(h,void 0,"message"),l?ot(n(h),void 0,"prehashed message"):h}function O(h,l,b){if(["recovered","canonical"].some(T=>T in b))throw new Error("sign() legacy options not supported");const{lowS:p,prehash:x,extraEntropy:B}=kt(b,g);h=P(h,x);const v=Y(h),_=ct(i,l),q=[Q(_),Q(v)];if(B!=null&&B!==!1){const T=B===!0?e(u.secretKey):B;q.push(L("extraEntropy",T))}const C=j(...q),U=v;function I(T){const k=V(T);if(!i.isValidNot0(k))return;const z=i.inv(k),K=t.BASE.multiply(k).toAffine(),M=i.create(K.x);if(M===J)return;const pt=i.create(z*i.create(U+M*_));if(pt===J)return;let Qt=(K.x===M?0:2)|Number(K.y&$),Jt=pt;return p&&S(pt)&&(Jt=i.neg(pt),Qt^=1),new A(M,Jt,Qt)}return{seed:C,k2sig:I}}function Et(h,l,b={}){h=L("message",h);const{seed:p,k2sig:x}=O(h,l,b);return ke(n.outputLen,i.BYTES,o)(p,x)}function rt(h){let l;const b=typeof h=="string"||Ot(h),p=!b&&h!==null&&typeof h=="object"&&typeof h.r=="bigint"&&typeof h.s=="bigint";if(!b&&!p)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(p)l=new A(h.r,h.s);else if(b){try{l=A.fromBytes(L("sig",h),"der")}catch(x){if(!(x instanceof tt.Err))throw x}if(!l)try{l=A.fromBytes(L("sig",h),"compact")}catch{return!1}}return l||!1}function N(h,l,b,p={}){const{lowS:x,prehash:B,format:v}=kt(p,g);if(b=L("publicKey",b),l=P(L("message",l),B),"strict"in p)throw new Error("options.strict was renamed to lowS");const _=v===void 0?rt(h):A.fromBytes(L("sig",h),v);if(_===!1)return!1;try{const q=t.fromBytes(b);if(x&&_.hasHighS())return!1;const{r:C,s:U}=_,I=Y(l),T=i.inv(U),k=i.create(I*T),z=i.create(C*T),K=t.BASE.multiplyUnsafe(k).add(q.multiplyUnsafe(z));return K.is0()?!1:i.create(K.x)===C}catch{return!1}}function w(h,l,b={}){const{prehash:p}=kt(b,g);return l=P(l,p),A.fromBytes(h,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:d,getPublicKey:m,getSharedSecret:y,utils:a,lengths:u,Point:t,sign:Et,verify:N,recoverPublicKey:w,Signature:A,hash:n})}function cn(t){const n={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp;let e=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0;const o=yt(n.n,{BITS:t.nBitLength,allowedLengths:e,modFromBytes:t.wrapPrivateKey}),s={Fp:r,Fn:o,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:n,curveOpts:s}}function fn(t){const{CURVE:n,curveOpts:r}=cn(t),e={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:n,curveOpts:r,hash:t.hash,ecdsaOpts:e}}function an(t,n){const r=n.Point;return Object.assign({},n,{ProjectivePoint:r,CURVE:Object.assign({},t,ve(r.Fn.ORDER,r.Fn.BITS))})}function un(t){const{CURVE:n,curveOpts:r,hash:e,ecdsaOpts:o}=fn(t),s=en(n,r),i=sn(s,e,o);return an(t,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ln(t,n){const r=e=>un({...t,hash:e});return{...r(n),create:r}}const dn=ft;function nt(t,n){if(mt(t),mt(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const r=Array.from({length:n}).fill(0);for(let e=n-1;e>=0;e--)r[e]=t&255,t>>>=8;return new Uint8Array(r)}function hn(t,n){const r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t[e]^n[e];return r}function mt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Ae(t){if(!Ot(t)&&typeof t!="string")throw new Error("DST must be Uint8Array or string");return typeof t=="string"?gt(t):t}function wn(t,n,r,e){qt(t),mt(r),n=Ae(n),n.length>255&&(n=e(j(gt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:s}=e,i=Math.ceil(r/o);if(r>65535||i>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=j(n,nt(n.length,1)),c=nt(0,s),d=nt(r,2),m=new Array(i),y=e(j(c,t,d,nt(0,1),f));m[0]=e(j(y,nt(1,1),f));for(let u=1;u<=i;u++){const g=[hn(y,m[u-1]),nt(u+1,1),f];m[u]=e(j(...g))}return j(...m).slice(0,r)}function mn(t,n,r,e,o){if(qt(t),mt(r),n=Ae(n),n.length>255){const s=Math.ceil(2*e/8);n=o.create({dkLen:s}).update(gt("H2C-OVERSIZE-DST-")).update(n).digest()}if(r>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:r}).update(t).update(nt(r,2)).update(n).update(nt(n.length,1)).digest()}function Lt(t,n,r){Nt(r,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:e,k:o,m:s,hash:i,expand:f,DST:c}=r;if(!Le(r.hash))throw new Error("expected valid hash");qt(t),mt(n);const d=e.toString(2).length,m=Math.ceil((d+o)/8),y=n*s*m;let a;if(f==="xmd")a=wn(t,c,y,i);else if(f==="xof")a=mn(t,c,y,o,i);else if(f==="_internal_pass")a=t;else throw new Error('expand must be "xmd" or "xof"');const u=new Array(n);for(let g=0;g<n;g++){const E=new Array(s);for(let S=0;S<s;S++){const R=m*(S+g*s),Z=a.subarray(R,R+m);E[S]=D(dn(Z),e)}u[g]=E}return u}function gn(t,n){const r=n.map(e=>Array.from(e).reverse());return(e,o)=>{const[s,i,f,c]=r.map(y=>y.reduce((a,u)=>t.add(t.mul(a,e),u))),[d,m]=Zt(t,[i,c],!0);return e=t.mul(s,d),o=t.mul(o,t.mul(f,m)),{x:e,y:o}}}const bn=gt("HashToScalar-");function yn(t,n,r){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function e(s){return t.fromAffine(n(s))}function o(s){const i=s.clearCofactor();return i.equals(t.ZERO)?t.ZERO:(i.assertValidity(),i)}return{defaults:r,hashToCurve(s,i){const f=Object.assign({},r,i),c=Lt(s,2,f),d=e(c[0]),m=e(c[1]);return o(d.add(m))},encodeToCurve(s,i){const f=r.encodeDST?{DST:r.encodeDST}:{},c=Object.assign({},r,f,i),d=Lt(s,1,c),m=e(d[0]);return o(m)},mapToCurve(s){if(!Array.isArray(s))throw new Error("expected array of bigints");for(const i of s)if(typeof i!="bigint")throw new Error("expected array of bigints");return o(e(s))},hashToScalar(s,i){const f=t.Fn.ORDER,c=Object.assign({},r,{p:f,m:1,DST:bn},i);return Lt(s,1,c)[0][0]}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},En={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},pn=BigInt(0),ie=BigInt(1),Yt=BigInt(2);function vn(t){const n=dt.p,r=BigInt(3),e=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),f=BigInt(44),c=BigInt(88),d=t*t*t%n,m=d*d*t%n,y=W(m,r,n)*m%n,a=W(y,r,n)*m%n,u=W(a,Yt,n)*d%n,g=W(u,o,n)*u%n,E=W(g,s,n)*g%n,S=W(E,f,n)*E%n,R=W(S,c,n)*S%n,Z=W(R,f,n)*E%n,A=W(Z,r,n)*m%n,V=W(A,i,n)*g%n,Y=W(V,e,n)*d%n,G=W(Y,Yt,n);if(!et.eql(et.sqr(G),t))throw new Error("Cannot find square root");return G}const et=yt(dt.p,{sqrt:vn}),Gt=ln({...dt,Fp:et,lowS:!0,endo:En},xt),ce={};function Rt(t,...n){let r=ce[t];if(r===void 0){const e=xt(gt(t));r=j(e,e),ce[t]=r}return xt(j(r,...n))}const Pt=t=>t.toBytes(!0).slice(1),ht=(()=>Gt.Point)(),Wt=t=>t%Yt===pn;function zt(t){const{Fn:n,BASE:r}=ht,e=ct(n,t),o=r.multiply(e);return{scalar:Wt(o.y)?e:n.neg(e),bytes:Pt(o)}}function Ie(t){const n=et;if(!n.isValidNot0(t))throw new Error("invalid x: Fail if x â‰¥ p");const r=n.create(t*t),e=n.create(r*t+BigInt(7));let o=n.sqrt(e);Wt(o)||(o=n.neg(o));const s=ht.fromAffine({x:t,y:o});return s.assertValidity(),s}const wt=ft;function Ne(...t){return ht.Fn.create(wt(Rt("BIP0340/challenge",...t)))}function fe(t){return zt(t).bytes}function Bn(t,n,r=At(32)){const{Fn:e}=ht,o=L("message",t),{bytes:s,scalar:i}=zt(n),f=L("auxRand",r,32),c=e.toBytes(i^wt(Rt("BIP0340/aux",f))),d=Rt("BIP0340/nonce",c,s,o),{bytes:m,scalar:y}=zt(d),a=Ne(m,s,o),u=new Uint8Array(64);if(u.set(m,0),u.set(e.toBytes(e.create(y+a*i)),32),!Ze(u,o,s))throw new Error("sign: Invalid signature produced");return u}function Ze(t,n,r){const{Fn:e,BASE:o}=ht,s=L("signature",t,64),i=L("message",n),f=L("publicKey",r,32);try{const c=Ie(wt(f)),d=wt(s.subarray(0,32));if(!$t(d,ie,dt.p))return!1;const m=wt(s.subarray(32,64));if(!$t(m,ie,dt.n))return!1;const y=Ne(e.toBytes(d),Pt(c),i),a=o.multiplyUnsafe(m).add(c.multiplyUnsafe(e.neg(y))),{x:u,y:g}=a.toAffine();return!(a.is0()||!Wt(g)||u!==d)}catch{return!1}}const Rn=(()=>{const r=(o=At(48))=>Se(o,dt.n);Gt.utils.randomSecretKey;function e(o){const s=r(o);return{secretKey:s,publicKey:fe(s)}}return{keygen:e,getPublicKey:fe,sign:Bn,verify:Ze,Point:ht,utils:{randomSecretKey:r,randomPrivateKey:r,taggedHash:Rt,lift_x:Ie,pointToBytes:Pt,numberToBytesBE:It,bytesToNumberBE:ft,mod:D},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:32*2,seed:48}}})(),xn=(()=>gn(et,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),Sn=(()=>rn(et,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:et.create(BigInt("-11"))}))(),Ue=(()=>yn(Gt.Point,t=>{const{x:n,y:r}=Sn(et.create(t[0]));return xn(n,r)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:et.ORDER,m:1,k:128,expand:"xmd",hash:xt}))(),qn=(()=>Ue.hashToCurve)(),On=(()=>Ue.encodeToCurve)();export{On as encodeToCurve,qn as hashToCurve,Rn as schnorr,Gt as secp256k1,Ue as secp256k1_hasher};
